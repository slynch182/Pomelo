<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="frame-ancestors 'self' https://accounts.google.com;">
  <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
  <script src="https://accounts.google.com/gsi/client" async defer></script>
  <script src="https://apis.google.com/js/platform.js" async defer></script>
  <title>Simple Webpage</title>
  <style>
    #buttonDiv {
      display: flex;
      justify-content: flex-start;
      margin-bottom: 20px;
    }

    /* Profile Picture */
    #profile-picture {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      margin-top: 10px;
      display: none;
    }

    /* Logout Button */
    #logout-button {
      background-color: #ff4b4b;
      color: white;
      font-size: 14px;
      padding: 8px 15px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      display: none; /* Initially hidden */
    }

    /* CSS to increase the width of the left column in the table */
    table th:first-child,
    table td:first-child {
      width: 200px; /* Adjust the width as needed */
    }
    
    /* CSS to set minimum width for the Date and Time column */
    table th:nth-child(2),
    table td:nth-child(2) {
      min-width: 200px;
    }
    /* CSS to add border to the table */
    table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
    }

    /* CSS to align headers to the left */
    th {
      text-align: left;
    }
  </style>
</head>
<body>

  <!-- Google Sign-In Button -->
  <div id="buttonDiv"></div>

  <!-- Logout Button -->
  <button id="logout-button" onclick="logout()">Sign Out</button>

  <p id="user-info">Hello! You are not signed in.</p>
  <img id="profile-picture" src="" alt="Profile Picture" referrerpolicy="no-referrer"/>
  
  <script type="module">
    import * as jose from 'https://cdn.jsdelivr.net/npm/jose@latest/dist/browser/index.min.js';
  
    async function verifyJWT(token) {
      try {
        console.log("Verifying token:", token);
        console.log("Using public key:", publicKey);  // Log the public key used
  
        // Decode the JWT header to get the algorithm
        const headerBase64Url = token.split('.')[0];
        const headerBase64 = headerBase64Url.replace(/-/g, '+').replace(/_/g, '/');
        const headerJson = JSON.parse(window.atob(headerBase64));
        const algorithm = headerJson.alg;
  
        console.log("JWT header:", headerJson);
        console.log("Algorithm:", algorithm);
  
        const key = await importPublicKey(publicKeyPEM, algorithm);
        console.log("Public key imported:", key);
        const { payload, header } = await jose.jwtVerify(token, key, { algorithms: [algorithm] });
        console.log("JWT payload:", payload);
        return { payload, header };
      } catch (error) {
        console.error("JWT verification failed:", error);
        throw new Error("JWT verification failed: " + error.message);
      }
    }
  
    async function importPublicKey(pem, algorithm) {
      if (algorithm.startsWith('HS')) {
        // For HMAC algorithms
        return await crypto.subtle.importKey(
          "raw",
          new TextEncoder().encode(pem),
          { name: "HMAC", hash: { name: `SHA-${algorithm.slice(2)}` } },
          true,
          ["verify"]
        );
      } else {
        // For RSA, ECDSA, EdDSA algorithms
        const binaryDerString = window.atob(pem.replace(/(-----(BEGIN|END) PUBLIC KEY-----|\n)/g, ""));
        const binaryDer = new Uint8Array(binaryDerString.length);
        for (let i = 0; i < binaryDerString.length; i++) {
          binaryDer[i] = binaryDerString.charCodeAt(i);
        }
  
        let algoParams;
        switch (algorithm) {
          case "RS256":
          case "RS384":
          case "RS512":
            algoParams = { name: "RSASSA-PKCS1-v1_5", hash: { name: algorithm.replace('RS', 'SHA-') } };
            break;
          case "PS256":
          case "PS384":
          case "PS512":
            algoParams = { name: "RSA-PSS", hash: { name: algorithm.replace('PS', 'SHA-') } };
            break;
          case "ES256":
            algoParams = { name: "ECDSA", namedCurve: "P-256" };
            break;
          case "ES384":
            algoParams = { name: "ECDSA", namedCurve: "P-384" };
            break;
          case "ES512":
            algoParams = { name: "ECDSA", namedCurve: "P-521" };
            break;
          case "EdDSA":
            algoParams = { name: "Ed25519" }; // Assuming Ed25519 for simplicity
            break;
          default:
            throw new Error("Unsupported algorithm: " + algorithm);
        }
  
        return await crypto.subtle.importKey(
          "spki",
          binaryDer.buffer,
          algoParams,
          true,
          ["verify"]
        );
      }
    }
  
    window.verifyJWT = verifyJWT;
    window.importPublicKey = importPublicKey;
  </script>
  
  <script>
    const CLIENT_ID = "937304914639-jvs3kcp6srocp481en53p7ajm8jvfq99.apps.googleusercontent.com";
    const USERINFO_URL = "https://www.googleapis.com/oauth2/v3/userinfo";
  
    function handleCredentialResponse(response) {
      const idToken = response.credential;
      const userData = decodeJwt(idToken); // Decode the JWT token to extract user data
  
      console.log("Decoded User Data:", userData); // Debugging info
  
      document.getElementById("user-info").innerHTML = `
        Welcome ${userData.name} (${userData.email})
      `;
      
      if (userData.picture) {
        document.getElementById("profile-picture").src = userData.picture;
        document.getElementById("profile-picture").style.display = "block";
      } else {
        document.getElementById("profile-picture").style.display = "none";
      }
      
      document.querySelector("#buttonDiv").style.display = "none";
      document.getElementById("logout-button").style.display = "block";
    }
  
    function decodeJwt(token) {
      let base64Url = token.split('.')[1];
      let base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
      return JSON.parse(decodeURIComponent(escape(atob(base64))));
    }
  
    function requestAccessToken() {
      google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID,
        scope: "openid profile email",
        prompt: "consent",
        callback: (response) => {
          if (response.access_token) {
            localStorage.setItem("access_token", response.access_token);
            fetchUserInfo(response.access_token);
          }
        }
      }).requestAccessToken();
    }
  
    function logout() {
      google.accounts.id.disableAutoSelect();
      document.getElementById("user-info").innerHTML = "Hello! You are not signed in.";
      document.getElementById("profile-picture").style.display = "none";
  
      document.querySelector("#buttonDiv").style.display = "flex";
      document.getElementById("logout-button").style.display = "none";
  
      // Clear the text box
      document.querySelector('input[name="text"]').value = '';
  
     // Clear the public key text area
      document.querySelector('textarea[name="public-key"]').value = '';

      // Clear the error message
      document.getElementById("error-message").innerText = '';
      
      clearTable(); // Clear the table on logout
      
      // Clear browser history
      history.replaceState(null, null, location.href);
      window.addEventListener('popstate', function() {
        history.pushState(null, null, location.href);
      });
    }
  
    function clearTable() {
      const tableBody = document.querySelector('tbody');
      tableBody.innerHTML = ''; // Clear all rows in the table body
    }
  
    // Run on page load
    window.onload = function () {
      google.accounts.id.initialize({
        client_id: CLIENT_ID,
        callback: handleCredentialResponse
      });
      google.accounts.id.renderButton(
        document.getElementById("buttonDiv"),
        { theme: "outline", size: "large", width: 180 }  // customization attributes
      );
      google.accounts.id.prompt(); // Also display the One Tap dialog

      // Clear the public key text area on page load
      document.querySelector('textarea[name="public-key"]').value = '';
    };
  </script>
  
  <script>
    // Public Key for ES256 Verification
    const publicKeyPEM = `-----BEGIN PUBLIC KEY-----
MFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEMU1JFVEO9FkVr0r041GpAWzKvQi1TBYm
arJj3+aNeC2aK9GT7Hct1OJGWQGbUkNWTeUr+Ui09PjBit+AMYuHgA==
-----END PUBLIC KEY-----`;
  
    async function handleSubmit(event) {
      event.preventDefault(); // Prevent form submission from reloading the page
  
      const textInput = document.querySelector(`input[name="text"]`);
      const publicKeyInput = document.querySelector(`textarea[name="public-key"]`);
      const userInput = textInput.value.trim();
      const table = document.querySelector('tbody');
      document.getElementById("error-message").innerText = ""; // Clear error messages
  
      if (!userInput) {
        document.getElementById("error-message").innerText = "Input cannot be empty.";
        textInput.focus();
        return;
      }

      // Use user-provided public key if available
      const userPublicKey = publicKeyInput.value.trim() || publicKeyPEM;

      // Format the date column to mm/dd/yyyy and the three letter time zone
      const now = new Date();
      const options = { month: '2-digit', day: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' };
      const formattedTime = now.toLocaleDateString('en-US', options).replace(',', '');
      const timezone = now.toLocaleTimeString('en-us',{timeZoneName:'short'}).split(' ')[2];
      
      if (isJWT(userInput)) {
        try {
          const decodedPayload = await window.verifyJWT(userInput, userPublicKey);
          addRow(table, JSON.stringify(decodedPayload, null, 2), userInput, true);
        } catch (error) {
          document.getElementById("error-message").innerText = error.message;
          addRow(table, JSON.stringify(decodeJwt(userInput), null, 2), userInput, false);
        }
      } else {
        addRow(table, userInput, '', false);
      }
        
      // Clear the text box and return focus
      textInput.value = '';
      textInput.focus();
    }
  
    function addRow(table, content, jwt, isValidJWT) {
      const row = table.insertRow();
      const contentCell = row.insertCell(0);
      const timeCell = row.insertCell(1);
      const jwtCell = row.insertCell(2);

      const now = new Date();
      const options = { month: '2-digit', day: '2-digit', year: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit', timeZoneName: 'short' };
      const formattedTime = now.toLocaleDateString('en-US', options).replace(',', '');
      const timezone = now.toLocaleTimeString('en-us',{timeZoneName:'short'}).split(' ')[2];
  
      contentCell.innerText = content;
      timeCell.innerText = formattedTime;
      jwtCell.innerText = jwt;
  
      if (isValidJWT) {
        row.style.backgroundColor = "red";
      }
    }
  
    function isJWT(token) {
      return /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+$/.test(token);
    }

    function clearPublicKey() {
      document.querySelector('textarea[name="public-key"]').value = '';
    }

  </script>

  <p></p>
  <form method="POST" onsubmit="handleSubmit(event)">
    <input type="text" name="text" placeholder="Enter text here">
    <button type="submit">Submit</button>
    <p id="error-message" style="color: red;"></p>
  </form>
  <h2>Submitted Text</h2>
  <table>
    <thead>
      <tr>
        <th>Text</th>
        <th>Date and Time</th>
        <th>JWT</th>
      </tr>
    </thead>
    <tbody>
    </tbody>
  </table>

  <h2>Enter Public Key</h2>
  <textarea name="public-key" rows="8" cols="100" placeholder="Enter your public key here..."></textarea>
  <button onclick="clearPublicKey()">Clear</button> <!-- Highlighted change: Added clear button -->

</body>
</html>
